# -*- coding: utf-8 -*-
"""Creavity Score Creation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hc1PvRTW-PQS-FwVBD0nYpWyp_3Fd3ja
"""

# STEP 1: INSTALL LIBRARIES
!pip install torch torchvision torchaudio
!pip install torch-geometric
!pip install pandas matplotlib scikit-learn

# STEP 2: IMPORT LIBRARIES
import pandas as pd
import json
import torch
import torch.nn as nn
import torch.nn.functional as F
import matplotlib.pyplot as plt
import networkx as nx
from torch.utils.data import Dataset, DataLoader
from torch_geometric.data import Data
from torch_geometric.nn import GCNConv
from collections import defaultdict
from sklearn.preprocessing import LabelEncoder

# STEP 3: UPLOAD MATCH FILES
from google.colab import files
uploaded = files.upload()

with open("7298.json") as f1, open("7430.json") as f2:
    data1 = json.load(f1)
    data2 = json.load(f2)

events = data1 + data2
flair_df = pd.json_normalize(events)

# STEP 4: DETECT FLAIR ACTIONS
def label_flair(row):
    base = 0
    bonus = 1.0
    if row['type.name'] == 'Dribble' and row.get('under_pressure') and row.get('dribble.outcome.name') == 'Complete':
        base = 1
        bonus = 1.0
    if 'nutmeg' in row and row['nutmeg'] is True:
        base = 1
        bonus = 1.5
    if row['type.name'] == 'Duel' and row.get('duel.outcome.name') == 'Success In Play' and row.get('location', [0])[0] > 66:
        base = 1
        bonus = 1.3
    if row['type.name'] == 'Pass' and row.get('under_pressure') and row.get('pass.outcome.name') is None:
        base = 1
        bonus = 1.2
    return pd.Series({'base_score': base, 'bonus': bonus})

flair_df[['base_score', 'bonus']] = flair_df.apply(label_flair, axis=1)
flair_df['creativity_score'] = flair_df['base_score'] * flair_df['bonus']

# STEP 5: SUM SCORES PER PLAYER
player_scores = flair_df.groupby('player.name')['creativity_score'].sum().reset_index()
player_scores = player_scores.sort_values(by='creativity_score', ascending=False)

# STEP 6: VISUALIZE
plt.figure(figsize=(10, 5))
plt.barh(player_scores['player.name'].head(10), player_scores['creativity_score'].head(10))
plt.xlabel("Creativity Score")
plt.title("Top 10 Players by Creativity")
plt.gca().invert_yaxis()
plt.show()

# STEP 7: TRANSFORMER SEQUENCES
player_sequences = defaultdict(list)
for _, row in flair_df.iterrows():
    act = row['type.name']
    press = 'P' if row.get('under_pressure') else 'N'
    token = f"{act}_{press}"
    player_sequences[row['player.name']].append(token)

tokenizer = LabelEncoder()
tokenizer.fit([t for seq in player_sequences.values() for t in seq])
encoded = {p: tokenizer.transform(seq) for p, seq in player_sequences.items() if len(seq) > 5}

# STEP 8: TRANSFORMER MODEL
class FlairTransformer(nn.Module):
    def __init__(self, vocab_size):
        super().__init__()
        self.embedding = nn.Embedding(vocab_size, 32)
        encoder = nn.TransformerEncoderLayer(d_model=32, nhead=2, batch_first=True)
        self.transformer = nn.TransformerEncoder(encoder, num_layers=2)
        self.fc = nn.Linear(32, 1)

    def forward(self, x):
        x = self.embedding(x)
        x = self.transformer(x)
        return self.fc(x.mean(dim=1))

class FlairDataset(Dataset):
    def __init__(self, sequences):
    self.data = [(torch.tensor(seq[:50] + [0]*(50-len(seq[:50]))), torch.tensor(len(seq)/10)) for seq in sequences.values()]
    def __len__(self): return len(self.data)
    def __getitem__(self, i): return self.data[i]

dset = FlairDataset(encoded)
loader = DataLoader(dset, batch_size=4, shuffle=True)

transformer_model = FlairTransformer(len(tokenizer.classes_))
opt = torch.optim.Adam(transformer_model.parameters(), lr=0.001)
loss_fn = nn.MSELoss()

transformer_model.train()
for x, y in loader:
    out = transformer_model(x).squeeze()
    loss = loss_fn(out, y)
    loss.backward()
    opt.step()
    opt.zero_grad()

# STEP 9: GNN GRAPH
flair_df['action_encoded'] = LabelEncoder().fit_transform(flair_df['type.name'])
top_players = flair_df['player.name'].value_counts().head(2).index.tolist()
sub_df = flair_df[flair_df['player.name'].isin(top_players)]

features = []
edges = []
idx = 0
prev_idx = None
for _, row in sub_df.iterrows():
    features.append([row['action_encoded'], float(row.get('under_pressure', False))])
    if prev_idx is not None:
        edges.append((prev_idx, idx))
    prev_idx = idx
    idx += 1

x = torch.tensor(features, dtype=torch.float)
edge_index = torch.tensor(edges, dtype=torch.long).t().contiguous()
graph_data = Data(x=x, edge_index=edge_index)

class SimpleGNN(nn.Module):
    def __init__(self, in_channels=2, hidden_channels=16):
        super().__init__()
        self.conv1 = GCNConv(in_channels, hidden_channels)
        self.conv2 = GCNConv(hidden_channels, 1)
    def forward(self, data):
        x, edge_index = data.x, data.edge_index
        x = self.conv1(x, edge_index).relu()
        return self.conv2(x, edge_index).mean(dim=0)

gnn_model = SimpleGNN()

# STEP 10: CREASCORENET
class CreaScoreNet(nn.Module):
    def __init__(self, gnn_model, transformer_model):
        super().__init__()
        self.gnn = gnn_model
        self.transformer = transformer_model
        self.fc = nn.Linear(2, 1)
    def forward(self, graph_data, seq):
        h_gnn = self.gnn(graph_data)
        h_trans = self.transformer(seq).mean(dim=1).squeeze()
        combined = torch.stack([h_gnn, h_trans.mean()]).unsqueeze(0)
        return self.fc(combined)

creascorenet = CreaScoreNet(gnn_model, transformer_model)

for x, y in loader:
    pred = creascorenet(graph_data, x)
    print("Predicted Creativity Score:", pred.item())
    break